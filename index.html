<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>首姿勢＋顔距離(Z)判定｜（2）9月改良版（Tasks+首角度）</title>
  <style>
    :root { --w: 360px; --h: 480px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP"; font-size: 18px; margin:0; color:#111; background:#fafafa; }
    header{ padding:12px 16px; background:#fff; border-bottom:1px solid #eee; position:sticky; top:0; z-index:10; }
    h1{ font-size:20px; margin:0; }
    main{ display:grid; grid-template-columns:1fr; gap:12px; padding:12px; place-items:center; }
    .stage{ display:grid; gap:8px; place-items:center; }
    video,canvas{ transform:scaleX(-1); width:var(--w); height:var(--h); border:1px solid #ddd; background:#000; border-radius:8px; }
    .controls{ display:flex; flex-wrap:wrap; gap:8px; justify-content:center; }
    button{ font-size:15px; padding:8px 14px; border-radius:10px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    button.primary{ background:#0ea5e9; color:#fff; border-color:#0ea5e9; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    .panel{ width:min(680px,92vw); background:#fff; border:1px solid #eee; border-radius:12px; padding:12px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre-line; }
    #warning{ font-size:24px; font-weight:800; text-align:center; margin:4px 0 0; }
    .ok{ color:#16a34a; } .bad{ color:#dc2626; }
    .hint{ color:#666; font-size:13px; }
    .badge{ display:inline-block; padding:2px 8px; border-radius:999px; background:#f1f5f9; font-size:12px; }
  </style>
</head>
<body>
  <header>
    <h1>首姿勢＋顔距離(Z)判定｜（2）9月改良版 <span class="badge">Tasks切替/首角度(顔-端末)/投票制</span></h1>
  </header>

  <main>
    <section class="stage">
      <div class="controls">
        <button id="startBtn" class="primary">測定開始</button>
        <button id="calibBtn" disabled>ニュートラルをキャリブレーション</button>
        <button id="resetBtn" disabled>キャリブ解除</button>
      </div>
      <video id="video" autoplay muted playsinline></video>
      <canvas id="canvas"></canvas>
    </section>

    <section class="panel">
      <div id="warning" class="ok">測定待機中</div>
      <div>
        <h3>現在値</h3>
        <div id="output" class="mono">読み取り中...</div>
      </div>
      <p class="hint">使い方：<strong>測定開始</strong> → 正しい姿勢で <strong>ニュートラルをキャリブ</strong>（任意）→ 不要なら <strong>キャリブ解除</strong>。iOS は開始時にセンサー許可が必要です。</p>
    </section>
  </main>

  <!-- MediaPipe (旧FaceMeshは使わず、Tasksを使用) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js"></script>

  <script>
    // ===== パラメータ =====
    const PARAMS = {
      alphaPitch: 0.25, alphaRoll: 0.25,
      alphaYdiff: 0.3, alphaNoseZ: 0.25,
      calibYdiff: null, calibNoseZ: null,
      // 相対判定（キャリブ後）
      downEnter: -0.035, downExit: -0.020,
      upEnter: 0.045,    upExit: 0.030,
      // 絶対判定（キャリブ無し時）
      absDownEnter: 0.11, absUpEnter: 0.19, absExitBand: 0.02,
      // 近遠（相対）
      closeEnter: -0.035, closeExit: -0.015, farEnter: 0.020, farExit: 0.005,
      // 近遠（絶対）
      absCloseEnter: -0.15, absFarEnter: -0.10, absZExitBand: 0.02,
      // 警告ON/OFFの持続
      sustainMs: 1800, clearMs: 900,
      // 投票制＆首角度
      neckAngleThresh: 15, // deg
      headPitchBent: -10   // deg (頭が前下がり気味)
    };

    // ===== 要素 =====
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const output = document.getElementById('output');
    const warning = document.getElementById('warning');
    const startBtn = document.getElementById('startBtn');
    const calibBtn = document.getElementById('calibBtn');
    const resetBtn = document.getElementById('resetBtn');

    // ===== センサー(端末の姿勢) =====
    let rawPitch=0, rawRoll=0; // device
    let sPitch=0, sRoll=0;     // smoothed device

    function handleOrientation(e){
      rawPitch = (e.beta ?? 0);
      rawRoll  = (e.gamma ?? 0);
      sPitch = PARAMS.alphaPitch * rawPitch + (1 - PARAMS.alphaPitch) * sPitch;
      sRoll  = PARAMS.alphaRoll  * rawRoll  + (1 - PARAMS.alphaRoll ) * sRoll;
    }

    // ===== Face Landmarker (Tasks) =====
    let landmarker = null; // インスタンス

    // 状態/一時変数
    let sYdiff=null, sNoseZ=null; // smoothed face features
    let faceState = { dir:'straight', prox:'通常距離' };
    let wasDown=false, wasUp=false, wasClose=false, wasFar=false;
    let bentState=false, enterStart=null, exitStart=null;

    // 描画補助
    function drawPoint(normLandmark, color){
      const x = normLandmark.x * canvas.width;
      const y = normLandmark.y * canvas.height;
      ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fillStyle = color; ctx.fill();
    }

    // 顔向き（yDiff）
    function classifyDirection(y){
      if (PARAMS.calibYdiff != null){
        const dy = y - PARAMS.calibYdiff;
        if (!wasDown && dy <= PARAMS.downEnter){ wasDown = true; wasUp=false; return 'down'; }
        if (wasDown && dy >= PARAMS.downExit){ wasDown = false; }
        if (!wasUp && dy >= PARAMS.upEnter){ wasUp = true; wasDown=false; return 'up'; }
        if (wasUp && dy <= PARAMS.upExit){ wasUp = false; }
        if (wasDown) return 'down'; if (wasUp) return 'up'; return 'straight';
      }else{
        const lower = PARAMS.absDownEnter, upper = PARAMS.absUpEnter, band = PARAMS.absExitBand;
        if (!wasDown && y < lower){ wasDown=true; wasUp=false; return 'down'; }
        if (wasDown && y > lower + band){ wasDown=false; }
        if (!wasUp && y > upper){ wasUp=true; wasDown=false; return 'up'; }
        if (wasUp && y < upper - band){ wasUp=false; }
        if (wasDown) return 'down'; if (wasUp) return 'up'; return 'straight';
      }
    }

    // 顔の近遠
    function classifyProximity(z){
      if (PARAMS.calibNoseZ != null){
        const dz = z - PARAMS.calibNoseZ;
        if (!wasClose && dz <= PARAMS.closeEnter){ wasClose=true; wasFar=false; return '顔が近い'; }
        if (wasClose && dz >= PARAMS.closeExit){ wasClose=false; }
        if (!wasFar && dz >= PARAMS.farEnter){ wasFar=true; wasClose=false; return '顔が遠い'; }
        if (wasFar && dz <= PARAMS.farExit){ wasFar=false; }
        if (wasClose) return '顔が近い'; if (wasFar) return '顔が遠い'; return '通常距離';
      }else{
        const close = PARAMS.absCloseEnter, far = PARAMS.absFarEnter, band = PARAMS.absZExitBand;
        if (!wasClose && z < close){ wasClose=true; wasFar=false; return '顔が近い'; }
        if (wasClose && z > close + band){ wasClose=false; }
        if (!wasFar && z > far){ wasFar=true; wasClose=false; return '顔が遠い'; }
        if (wasFar && z < far - band){ wasFar=false; }
        if (wasClose) return '顔が近い'; if (wasFar) return '顔が遠い'; return '通常距離';
      }
    }

    // 投票制 + 首角度
    function isBent(dir, prox, devicePitchDeg, headPitchDeg){
      const neckAngle = headPitchDeg - devicePitchDeg; // 顔 - 端末
      let votes = 0;
      if (prox === '顔が近い') votes++;
      if (dir === 'down') votes++;
      if (headPitchDeg <= PARAMS.headPitchBent) votes++;
      if (Math.abs(neckAngle) >= PARAMS.neckAngleThresh) votes++;
      return { bent: votes >= 2, neckAngle };
    }

    function updateSustain(isNow){
      const t = performance.now();
      if (isNow){
        if (enterStart == null) enterStart = t; exitStart = null;
        const elapsed = t - enterStart;
        if (!bentState && elapsed >= PARAMS.sustainMs){ bentState = true; setWarning(true, '首が曲がっています'); }
      }else{
        if (exitStart == null) exitStart = t; enterStart = null;
        const elapsed = t - exitStart;
        if (bentState && elapsed >= PARAMS.clearMs){ bentState = false; setWarning(false, '首は曲がっていません'); }
        if (!bentState) setWarning(false, '首は曲がっていません');
      }
    }

    function setWarning(bad, text){ warning.textContent = text; warning.className = bad ? 'bad' : 'ok'; }

    // ===== カメラ =====
    async function initCamera(){
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'user', width:{ideal:640}, height:{ideal:480}, frameRate:{ideal:30, max:60} }, audio:false });
      video.srcObject = stream;
      await new Promise(r => video.onloadedmetadata = r);
      canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    }

    // ===== Tasks 初期化 =====
    async function initLandmarker(){
      const { FaceLandmarker, FilesetResolver, VisionRunningMode } = window;
      const fileset = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
      landmarker = await FaceLandmarker.createFromOptions(fileset, {
        baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task" },
        runningMode: VisionRunningMode.VIDEO,
        numFaces: 1,
        outputFaceBlendshapes: false,
        outputFacialTransformationMatrixes: true,
      });
    }

    function rad2deg(r){ return r * 180 / Math.PI; }

    // 4x4行列 → Yaw/Pitch/Roll（列優先）
    function matrixToEulerDeg(M){
      const m00=M[0], m01=M[4], m02=M[8];
      const m10=M[1], m11=M[5], m12=M[9];
      const m20=M[2], m21=M[6], m22=M[10];
      const yaw   = Math.atan2(m10, m00);
      const pitch = Math.atan2(-m20, Math.hypot(m21, m22));
      const roll  = Math.atan2(m21, m22);
      return { yaw:rad2deg(yaw), pitch:rad2deg(pitch), roll:rad2deg(roll) };
    }

    // ===== ループ =====
    function loop(){
      if (!landmarker) return;
      const now = performance.now();
      const res = landmarker.detectForVideo(video, now);

      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      if (!res || !res.faceLandmarks || res.faceLandmarks.length === 0){
        setWarning(false, '顔が検出できません');
        output.textContent = '顔が見つかりません';
        requestAnimationFrame(loop); return;
      }

      const lm = res.faceLandmarks[0];
      const nose = lm[1];
      const chin = lm[152];
      drawPoint(nose, '#22c55e');
      drawPoint(chin, '#2563eb');

      // yDiff / z を平滑
      const yDiff = (chin.y - nose.y);
      const noseZ = nose.z;
      sYdiff = (sYdiff==null)? yDiff : PARAMS.alphaYdiff * yDiff + (1-PARAMS.alphaYdiff)*sYdiff;
      sNoseZ = (sNoseZ==null)? noseZ : PARAMS.alphaNoseZ * noseZ + (1-PARAMS.alphaNoseZ)*sNoseZ;

      const dir = classifyDirection(sYdiff); faceState.dir = dir;
      const prox = classifyProximity(sNoseZ); faceState.prox = prox;

      // 顔の姿勢（頭部ポーズ）
      let headPitch=0, headYaw=0, headRoll=0;
      if (res.facialTransformationMatrixes && res.facialTransformationMatrixes.length){
        const M = res.facialTransformationMatrixes[0].data; // Float32Array(16)
        const e = matrixToEulerDeg(M); headPitch=e.pitch; headYaw=e.yaw; headRoll=e.roll;
      }

      // 最終判定（投票制 + 首角）
      const { bent, neckAngle } = isBent(faceState.dir, faceState.prox, sPitch, headPitch);
      updateSustain(bent);

      output.textContent =
        `Device Pitch: ${sPitch.toFixed(1)}°\n`+
        `Head  Pitch: ${headPitch.toFixed(1)}°  (Yaw:${headYaw.toFixed(1)}°, Roll:${headRoll.toFixed(1)}°)\n`+
        `Neck  Angle: ${neckAngle.toFixed(1)}°\n`+
        `yDiff(平滑): ${sYdiff?.toFixed(4)} / noseZ(平滑): ${sNoseZ?.toFixed(4)}\n`+
        `顔向き: ${faceState.dir} / 顔距離: ${faceState.prox}`;

      requestAnimationFrame(loop);
    }

    // ===== スタート =====
    async function startAll(){
      // iOS: センサー許可
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
        try{
          const res = await DeviceOrientationEvent.requestPermission();
          if (res === 'granted') window.addEventListener('deviceorientation', handleOrientation);
          else { output.textContent = 'センサーの利用が許可されませんでした。'; return; }
        }catch{ output.textContent = 'センサー許可でエラーが発生しました。'; return; }
      }else{
        window.addEventListener('deviceorientation', handleOrientation);
      }

      await initCamera();
      await initLandmarker();

      startBtn.disabled = true; calibBtn.disabled = false; resetBtn.disabled = false;
      setWarning(false, '測定中...');

      const saved = loadCalibration();
      if (saved) { PARAMS.calibYdiff = saved.y; PARAMS.calibNoseZ = saved.z; }

      requestAnimationFrame(loop);
    }

    // ===== キャリブ =====
    function calibrate(){
      if (sYdiff==null || sNoseZ==null) return;
      PARAMS.calibYdiff = sYdiff; PARAMS.calibNoseZ = sNoseZ; saveCalibration(PARAMS.calibYdiff, PARAMS.calibNoseZ);
      setWarning(false, 'ニュートラルを登録しました');
    }

    function resetCalibration(){
      PARAMS.calibYdiff = null; PARAMS.calibNoseZ = null; try{ localStorage.removeItem('posture-calib'); }catch{}
      sYdiff = null; sNoseZ = null; wasDown = wasUp = wasClose = wasFar = false; enterStart=exitStart=null; bentState=false; faceState={dir:'straight', prox:'通常距離'};
      setWarning(false, 'キャリブを解除しました');
      output.textContent = `Device Pitch: ${sPitch.toFixed(1)}°\nHead Pitch: --\nNeck Angle: --`;
    }

    function saveCalibration(y,z){ try{ localStorage.setItem('posture-calib', JSON.stringify({y,z})); }catch{} }
    function loadCalibration(){ try{ return JSON.parse(localStorage.getItem('posture-calib')); }catch{ return null; } }

    window.addEventListener('load', ()=>{
      startBtn.addEventListener('click', startAll);
      calibBtn.addEventListener('click', calibrate);
      resetBtn.addEventListener('click', resetCalibration);
    });
  </script>
</body>
</html>
